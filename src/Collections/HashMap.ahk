#Include "%A_LineFile%\..\..\Base\Eq.ahk"
#Include "%A_LineFile%\..\..\Base\Hash.ahk"
#Include "%A_LineFile%\..\..\Interfaces\IMap.ahk"

/**
 * A simple hash table implementation.
 * 
 * Instead of relying on object identitiy as keys, `HashMap` is able to
 * compare keys with user-defined `.Eq()` methods.
 * 
 * Elements are distributed into buckets using a hash code generated by
 * calling `.Hash()` on the value.
 * 
 * Keys must implement proper `.Eq()` and `.Hash()` methods. For more
 * information, refer to {@link AquaHotkey_Eq} and {@link AquaHotkey_Hash}.
 * 
 * @module  <Collections/HashMap>
 * @author  0w0Demonic
 * @see     https://www.github.com/0w0Demonic/AquaHotkey
 * @example
 * M := HashMap()
 * 
 * M.Set([1, 2], "old value")
 * M.Set([1, 2], "new value") ; [1, 2].Eq([1, 2]) => true
 * 
 * MsgBox(M.Count) ; 1
 * MsgBox(M.Get([1, 2])) ; "new value"
 */
class HashMap extends IMap {
    ;@region Configuration

    /**
     * Standard load factor to indicate the percentage of full the HashMap
     * is allowed to become before being resized.
     * 
     * @returns {Number}
     */
    static LoadFactor => (this.Prototype).LoadFactor

    /**
     * Initial minimum capacity of the HashMap.
     * 
     * @returns {Integer}
     */
    static InitialCap => (this.Prototype).InitialCap

    /**
     * Standard load factor to indicate the percentage of full the HashMap
     * is allowed to become before being resized.
     * 
     * @returns {Number}
     */
    LoadFactor => 0.75

    /**
     * Initial minimum capacity of the HashMap.
     * 
     * @returns {Integer}
     */
    InitialCap => 16

    ;@endregion
    ;---------------------------------------------------------------------------
    ;@region Fields

    /**
     * Retrieves the size of this HashMap.
     * 
     * @returns {Integer}
     */
    Count => this.Size

    /**
     * The size of this HashMap.
     * 
     * @readonly
     * @type {Integer}
     */
    Size := 0

    /**
     * Bit mask used for creating index.
     * 
     * @private
     * @returns {Integer}
     */
    Mask => (this.Capacity - 1)

    /**
     * The buckets which contain the elements of the HashMap.
     * 
     * @private
     * @type {Array}
     */
    Buckets := Array()

    /**
     * Resizes the HashMap based on the given amount of elements that it
     * should hold.
     * 
     * @private
     * @param   {Integer}  Cap  minimum capacity
     */
    Resize(CurrentSize) {
        Cap := this.Capacity
        while (CurrentSize > (Cap * this.LoadFactor)) {
            Cap <<= 1
        } else {
            return
        }

        OldBuckets       := this.Buckets
        Buckets          := Array()
        Buckets.Capacity := Cap

        loop (Cap) {
            Buckets.Push(false)
        }

        this.Buckets  := Buckets
        this.DefineProp("Capacity", { Get: (_) => Cap })

        for Bucket in OldBuckets {
            if (!Bucket) {
                continue
            }
            for Entry in Bucket {
                this.Set(Entry.Ket, Entry.Value)
            }
        }
    }

    ;@endregion
    ;---------------------------------------------------------------------------
    ;@region Construction

    /**
     * Creates a new HashMap, containing the specified elements.
     * 
     * @constructor
     * @param   {Any*}  Values  zero or more elements
     */
    __New(Values*) {
        if (Values.Length & 1) {
            throw ValueError("invalid param count",, Values.Length)
        }
        Cap := this.InitialCap
        this.DefineProp("Capacity", { Get: (_) => Cap })
        Buckets := this.Buckets
        Buckets.Length := Cap
        loop (Cap) {
            Buckets[A_Index] := false
        }

        this.Set(Values*)
    }

    ;@endregion
    ;---------------------------------------------------------------------------
    ;@region Methods

    /**
     * Clears this HashMap.
     */
    Clear() {
        B := this.Buckets
        loop (B.Length) {
            B[A_Index] := false
        }
        this.Size := 0
    }

    /**
     * Creates a shallow clone of the HashMap; the keys and values themselves are not
     * cloned.
     * 
     * @returns {HashMap}
     */
    Clone() {
        Result := Object()
        ObjSetBase(Result, ObjGetBase(this))
        Result.Size := this.Size

        Cap := this.Capacity
        Result.DefineProp("Capacity", { Get: (_) => Cap })

        NewBuckets := Array()
        OldBuckets := this.Buckets

        NewBuckets.Length := 0
        NewBuckets.Capacity := OldBuckets.Capacity

        for Bucket in OldBuckets {
            if (!Bucket) {
                NewBuckets.Push(false)
                continue
            }
            NewBucket := Array()
            NewBucket.Capacity := Bucket.Length
            for Entry in Bucket {
                NewBucket.Push(Entry.Clone())
            }
            NewBuckets.Push(NewBucket)
        }

        Result.Buckets := NewBuckets
        return Result
    }

    /**
     * Deletes an item from the HashMap.
     * 
     * @param   {Any}   Key  map key
     * @returns {Any}
     */
    Delete(Key) {
        Index := (Key.HashCode() & this.Mask) + 1

        Bucket := this.Buckets.Get(Index)
        if (Bucket) {
            for Entry in Bucket {
                if (Key.Eq(Entry.Key)) {
                    Bucket.RemoveAt(A_Index)
                    --this.Size
                    return Entry.Value
                }
            }
        }
        throw UnsetItemError("Value not found",, String(Key))
    }

    /**
     * Returns the value associated with the given map key.
     * 
     * @param   {Any}   Key      map key
     * @param   {Any?}  Default  default value, if absent
     * @returns {Any}
     */
    Get(Key, Default?) {
        Index := (Key.HashCode() & this.Mask) + 1

        Bucket := this.Buckets.Get(Index)
        if (Bucket) {
            for Entry in Bucket {
                if (Key.Eq(Entry.Key)) {
                    return Entry.Value
                }
            }
        }
        if (IsSet(Default)) {
            return Default
        }
        if (HasProp(this, "Default")) {
            return this.Default
        }
        throw UnsetItemError("Value not found",, String(Key))
    }

    /**
     * Determines whether the map has an entry with the specified map key.
     * 
     * @param   {Any}           Key       map key
     * @param   {VarRef<Any>?}  OutValue  (out) the associated key, if present
     * @returns {Boolean}
     */
    Has(Key, &OutValue?) {
        Index := (Key.HashCode() & this.Mask) + 1
        Bucket := this.Buckets.Get(Index)

        if (Bucket) {
            for Entry in Bucket {
                if (Key.Eq(Entry.Key)) {
                    OutValue := Entry.Value
                    return true
                }
            }
        }
        OutValue := unset
        return false
    }

    /**
     * Sets items in the HashMap.
     * 
     * @param   {Any*}  Values  alternating key and value
     */
    Set(Values*) {
        if (Values.Length & 1) {
            throw ValueError("Invalid param count",, Values.Length)
        }

        this.Resize(this.Size + Values.Length)
        Enumer := Values.__Enum(1)
        Buckets := this.Buckets

        itemPair:
        while (Enumer(&Key) && Enumer(&Value)) {
            Index  := (Key.HashCode() & this.Mask) + 1
            Bucket := this.Buckets.Get(Index)

            if (!Bucket) {
                Buckets[Index] := Array({ Key: Key, Value: Value })
                ++this.Size
                continue
            }

            for Entry in Bucket {
                if (Key.Eq(Entry.Key)) {
                    Entry.Value := Value
                    continue itemPair
                }
            }

            Bucket.Push({ Key: Key, Value: Value })
            ++this.Size
        }
    }

    /**
     * Returns an `Enumerator` that enumerates the elements of this HashMap.
     * 
     * @param   {Integer}  ArgSize  param size of for-loop
     * @returns {Enumerator}
     */
    __Enum(ArgSize) {
        Buckets := this.Buckets.__Enum(1)
        Entries := (*) => false
        return Enumer

        Enumer(&Key, &Value?) {
            loop {
                if (Entries(&Entry)) {
                    Key := Entry.Key
                    Value := Entry.Value
                    return true
                }
                loop {
                    if (!Buckets(&Bucket)) {
                        return false
                    }
                } until (Bucket)
                Entries := Bucket.__Enum()
            }
        }
    }

    ;@endregion
    ;---------------------------------------------------------------------------
    ;@region Properties

    /**
     * Gets and retrieves the capacity of the HashMap.
     * 
     * @param   {Integer}  Value  new capacity
     * @returns {Integer}
     */
    Capacity {
        get {
            throw UnsetError("Capacity not found")
        }
        set {
            this.Resize(Value)
        }
    }

    /**
     * Gets and sets items in the HashMap.
     * 
     * @param   {Any}  Key    map key
     * @param   {Any}  Value  associated value
     * @returns {Any}
     */
    __Item[Key] {
        get => this.Get(Key)
        set {
            this.Set(Key, Value)
        }
    }

    ;@endregion
}